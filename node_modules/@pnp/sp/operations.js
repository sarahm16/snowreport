import { __awaiter, __generator } from "tslib";
import { defaultPipelineBinder, cloneQueryableData, headers } from "@pnp/odata";
import { SPHttpClient } from "./sphttpclient.js";
import { mergeOptions, objectDefinedNotNull, isFunc } from "@pnp/common";
import { toAbsoluteUrl } from "./utils/toabsoluteurl.js";
export function registerCustomRequestClientFactory(requestClientFactory) {
    httpClientFactory = isFunc(requestClientFactory) ? function () { return requestClientFactory; } : defaultFactory;
}
var defaultFactory = function (runtime) { return function () { return new SPHttpClient(runtime); }; };
var httpClientFactory = defaultFactory;
var send = function (method) {
    return function (o, options) {
        return __awaiter(this, void 0, void 0, function () {
            var runtime, operation, data, batchDependency, url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        runtime = o.getRuntime();
                        operation = defaultPipelineBinder(httpClientFactory(runtime))(method);
                        data = cloneQueryableData(o.data);
                        batchDependency = objectDefinedNotNull(data.batch) ? data.batch.addDependency() : function () {
                            return;
                        };
                        return [4 /*yield*/, toAbsoluteUrl(o.toUrlAndQuery(), runtime)];
                    case 1:
                        url = _a.sent();
                        mergeOptions(data.options, options);
                        return [2 /*return*/, operation(Object.assign({}, data, {
                                batchDependency: batchDependency,
                                url: url,
                            }))];
                }
            });
        });
    };
};
export var spGet = function (o, options) {
    // Fix for #304 - when we clone objects we in some cases then execute a get request
    // in these cases the caching settings were getting dropped from the request
    // this tracks if the object from which this was cloned was caching and applies that to an immediate get request
    // does not affect objects cloned from this as we are using different fields to track the settings so it won't
    // be triggered
    if (o.data.cloneParentWasCaching) {
        o.usingCaching(o.data.cloneParentCacheOptions);
    }
    // if we are forcing caching set that in the data here
    if (o._forceCaching) {
        o.data.useCaching = true;
    }
    return send("GET")(o, options);
};
export var spPost = function (o, options) { return send("POST")(o, options); };
export var spDelete = function (o, options) { return send("DELETE")(o, options); };
export var spPatch = function (o, options) { return send("PATCH")(o, options); };
export var spPostDelete = function (o, options) {
    var opts = Object.assign(headers({ "X-HTTP-Method": "DELETE" }), options);
    return spPost(o, opts);
};
export var spPostDeleteETag = function (o, options, eTag) {
    if (eTag === void 0) { eTag = "*"; }
    var opts = Object.assign(headers({ "X-HTTP-Method": "DELETE", "IF-Match": eTag }), options);
    return spPost(o, opts);
};
//# sourceMappingURL=operations.js.map