import { __assign, __awaiter, __decorate, __extends, __generator, __read, __spreadArray } from "tslib";
import { isArray } from "@pnp/common";
import { defaultPath } from "../decorators.js";
import { _SharePointQueryableCollection, spInvokableFactory, _SharePointQueryableInstance } from "../sharepointqueryable.js";
import { tag } from "../telemetry.js";
/**
 * Describes a collection of Form objects
 *
 */
var _TermStore = /** @class */ (function (_super) {
    __extends(_TermStore, _super);
    function _TermStore() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(_TermStore.prototype, "groups", {
        /**
         * Gets the term groups associated with this tenant
         */
        get: function () {
            return tag.configure(TermGroups(this), "txts.groups");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_TermStore.prototype, "sets", {
        /**
         * Gets the term groups associated with this tenant
         */
        get: function () {
            return tag.configure(TermSets(this), "txts.sets");
        },
        enumerable: false,
        configurable: true
    });
    _TermStore = __decorate([
        defaultPath("_api/v2.1/termstore")
    ], _TermStore);
    return _TermStore;
}(_SharePointQueryableInstance));
export { _TermStore };
export var TermStore = spInvokableFactory(_TermStore);
var _TermGroups = /** @class */ (function (_super) {
    __extends(_TermGroups, _super);
    function _TermGroups() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a term group by id
     *
     * @param id Id of the term group to access
     */
    _TermGroups.prototype.getById = function (id) {
        return tag.configure(TermGroup(this, id), "txtgs.getById");
    };
    _TermGroups = __decorate([
        defaultPath("groups")
    ], _TermGroups);
    return _TermGroups;
}(_SharePointQueryableCollection));
export { _TermGroups };
export var TermGroups = spInvokableFactory(_TermGroups);
var _TermGroup = /** @class */ (function (_super) {
    __extends(_TermGroup, _super);
    function _TermGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(_TermGroup.prototype, "sets", {
        /**
         * Gets the term sets associated with this tenant
         */
        get: function () {
            return tag.configure(TermSets(this, "sets"), "txtg.sets");
        },
        enumerable: false,
        configurable: true
    });
    return _TermGroup;
}(_SharePointQueryableInstance));
export { _TermGroup };
export var TermGroup = spInvokableFactory(_TermGroup);
var _TermSets = /** @class */ (function (_super) {
    __extends(_TermSets, _super);
    function _TermSets() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a term group by id
     *
     * @param id Id of the term group to access
     */
    _TermSets.prototype.getById = function (id) {
        return tag.configure(TermSet(this, id), "txts.getById");
    };
    _TermSets = __decorate([
        defaultPath("sets")
    ], _TermSets);
    return _TermSets;
}(_SharePointQueryableCollection));
export { _TermSets };
export var TermSets = spInvokableFactory(_TermSets);
var _TermSet = /** @class */ (function (_super) {
    __extends(_TermSet, _super);
    function _TermSet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(_TermSet.prototype, "terms", {
        /**
         * Gets all the terms in this set
         */
        get: function () {
            return Terms(this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_TermSet.prototype, "parentGroup", {
        get: function () {
            return tag.configure(TermGroup(this, "parentGroup"), "txts.parentGroup");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_TermSet.prototype, "children", {
        get: function () {
            return tag.configure(Children(this), "txts.children");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_TermSet.prototype, "relations", {
        get: function () {
            return tag.configure(Relations(this), "txts.relations");
        },
        enumerable: false,
        configurable: true
    });
    _TermSet.prototype.getTermById = function (id) {
        return tag.configure(this.clone(Term, "terms/" + id), "txts.getTermById");
    };
    /**
     * Gets all the terms in this termset in an ordered tree using the appropriate sort ordering
     * ** This is an expensive operation and you should strongly consider caching the results **
     *
     * @param props Optional set of properties controlling how the tree is retrieved.
     */
    _TermSet.prototype.getAllChildrenAsOrderedTree = function (props) {
        if (props === void 0) { props = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var selects, setInfo, tree, ensureOrder, visitor;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        selects = ["*", "customSortOrder"];
                        if (props.retrieveProperties) {
                            selects.push("properties", "localProperties");
                        }
                        return [4 /*yield*/, this.select.apply(this, __spreadArray([], __read(selects), false))()];
                    case 1:
                        setInfo = _a.sent();
                        tree = [];
                        ensureOrder = function (terms, sorts, setSorts) {
                            // handle no custom sort information present
                            if (!isArray(sorts) && !isArray(setSorts)) {
                                return terms;
                            }
                            var ordering = null;
                            if (sorts === null && setSorts.length > 0) {
                                ordering = __spreadArray([], __read(setSorts), false);
                            }
                            else {
                                var index = sorts.findIndex(function (v) { return v.setId === setInfo.id; });
                                if (index >= 0) {
                                    ordering = __spreadArray([], __read(sorts[index].order), false);
                                }
                            }
                            if (ordering !== null) {
                                var orderedChildren_1 = [];
                                ordering.forEach(function (o) {
                                    var found = terms.find(function (ch) { return o === ch.id; });
                                    if (found) {
                                        orderedChildren_1.push(found);
                                    }
                                });
                                // we have a case where if a set is ordered and a term is added to that set
                                // AND the ordering information hasn't been updated in the UI the new term will not have
                                // any associated ordering information. See #1547 which reported this. So here we
                                // append any terms remaining in "terms" not in "orderedChildren" to the end of "orderedChildren"
                                orderedChildren_1.push.apply(orderedChildren_1, __spreadArray([], __read(terms.filter(function (info) { return ordering.indexOf(info.id) < 0; })), false));
                                return orderedChildren_1;
                            }
                            return terms;
                        };
                        visitor = function (source, parent) { return __awaiter(_this, void 0, void 0, function () {
                            var children, i, child, orderedTerm;
                            var _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4 /*yield*/, (_a = source.children).select.apply(_a, __spreadArray([], __read(selects), false))()];
                                    case 1:
                                        children = _b.sent();
                                        i = 0;
                                        _b.label = 2;
                                    case 2:
                                        if (!(i < children.length)) return [3 /*break*/, 6];
                                        child = children[i];
                                        orderedTerm = __assign({ children: [], defaultLabel: child.labels.find(function (l) { return l.isDefault; }).name }, child);
                                        if (!(child.childrenCount > 0)) return [3 /*break*/, 4];
                                        return [4 /*yield*/, visitor(this.getTermById(children[i].id), orderedTerm.children)];
                                    case 3:
                                        _b.sent();
                                        orderedTerm.children = ensureOrder(orderedTerm.children, child.customSortOrder);
                                        _b.label = 4;
                                    case 4:
                                        parent.push(orderedTerm);
                                        _b.label = 5;
                                    case 5:
                                        i++;
                                        return [3 /*break*/, 2];
                                    case 6: return [2 /*return*/];
                                }
                            });
                        }); };
                        return [4 /*yield*/, visitor(this, tree)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, ensureOrder(tree, null, setInfo.customSortOrder)];
                }
            });
        });
    };
    return _TermSet;
}(_SharePointQueryableInstance));
export { _TermSet };
export var TermSet = spInvokableFactory(_TermSet);
var _Children = /** @class */ (function (_super) {
    __extends(_Children, _super);
    function _Children() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    _Children = __decorate([
        defaultPath("children")
    ], _Children);
    return _Children;
}(_SharePointQueryableCollection));
export { _Children };
export var Children = spInvokableFactory(_Children);
var _Terms = /** @class */ (function (_super) {
    __extends(_Terms, _super);
    function _Terms() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a term group by id
     *
     * @param id Id of the term group to access
     */
    _Terms.prototype.getById = function (id) {
        return Term(this, id);
    };
    _Terms = __decorate([
        defaultPath("terms")
    ], _Terms);
    return _Terms;
}(_SharePointQueryableCollection));
export { _Terms };
export var Terms = spInvokableFactory(_Terms);
var _Term = /** @class */ (function (_super) {
    __extends(_Term, _super);
    function _Term() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(_Term.prototype, "children", {
        get: function () {
            return tag.configure(Children(this), "txt.children");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_Term.prototype, "relations", {
        get: function () {
            return tag.configure(Relations(this), "txt.relations");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_Term.prototype, "set", {
        get: function () {
            return tag.configure(TermSet(this, "set"), "txt.set");
        },
        enumerable: false,
        configurable: true
    });
    return _Term;
}(_SharePointQueryableInstance));
export { _Term };
export var Term = spInvokableFactory(_Term);
var _Relations = /** @class */ (function (_super) {
    __extends(_Relations, _super);
    function _Relations() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a term group by id
     *
     * @param id Id of the term group to access
     */
    _Relations.prototype.getById = function (id) {
        return tag.configure(Relation(this, id), "txrs.getById");
    };
    _Relations = __decorate([
        defaultPath("relations")
    ], _Relations);
    return _Relations;
}(_SharePointQueryableCollection));
export { _Relations };
export var Relations = spInvokableFactory(_Relations);
var _Relation = /** @class */ (function (_super) {
    __extends(_Relation, _super);
    function _Relation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(_Relation.prototype, "fromTerm", {
        get: function () {
            return tag.configure(Term(this, "fromTerm"), "txr.fromTerm");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_Relation.prototype, "toTerm", {
        get: function () {
            return tag.configure(Term(this, "toTerm"), "txr.toTerm");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_Relation.prototype, "set", {
        get: function () {
            return tag.configure(TermSet(this, "set"), "txr.set");
        },
        enumerable: false,
        configurable: true
    });
    return _Relation;
}(_SharePointQueryableInstance));
export { _Relation };
export var Relation = spInvokableFactory(_Relation);
//# sourceMappingURL=types.js.map