const { client, resolvePath, writeStream } = require('./base')

const clientOptions = {
  dataType: 'stream',
}

const castEid = 'Opt5S8PjwKwnVSHdJDoj'

const payload = {
  data: {
    introTop: 'Intro on the Top',
    introBottom: 'Intro on the Bottom',
    office: ['MAIN OFFICE', 'SATELLITE OFFICE'],
    items: [
      ['Main Item 1', 'Main Item 2', 'Main Item 3', 'Main Item 4', 'Main Item 5'],
      ['Satellite Item 1', 'Satellite Item 2', 'Satellite Item 3', 'Satellite Priceless Item'],
    ],
    prices: [
      ['$100', '$200', '$300', '$400', '$500'],
      ['$100', '$200', '$300'],
    ],
    outroTop: 'Outro on the Top',
    outroBottom: 'Outro on the Bottom',
  },
}

const numberTotal = 50
const delayMs = 10

function sleep (ms) {
  console.log(`Sleeping for ${ms}ms`)
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms)
  })
}

const parallel = async () => {
  const promises = []
  for (let i = 0; i < numberTotal; i++) {
    promises.push(doIteration(i))
    await sleep(delayMs)
  }

  return Promise.all(promises)
}

const series = async () => {
  for (let i = 0; i < numberTotal; i++) {
    await doIteration(i)
  }
}

async function doIteration (i) {
  console.log({iteration: i})
  const outputPath = resolvePath(__dirname, `fill-${castEid}-${i}.pdf`)
  const { statusCode, data, errors } = await client.fillPDF(castEid, payload, clientOptions)
  if (data) {
    await writeStream({ data, path: outputPath })
  } else {
    console.log({ statusCode, data, errors })
  }

  return outputPath
}

let main
main = parallel
// main = series

main()
  .then(console.log)
  .catch(console.warning)
