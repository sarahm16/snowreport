// https://www.npmjs.com/package/node-fetch#fetch-options
// https://github.com/form-data/form-data#void-append-string-field-mixed-value--mixed-options-
// https://www.npmjs.com/package/extract-files/v/6.0.0#type-extractablefilematcher
// https://github.com/jaydenseric/graphql-upload/issues/125
// https://zach.codes/building-a-file-upload-hook/
// https://github.com/jaydenseric/graphql-react/blob/1b1234de5de46b7a0029903a1446dcc061f37d09/src/universal/graphqlFetchOptions.mjs

// https://www.npmjs.com/package/file-type
// https://www.npmjs.com/package/buffer-peek-stream

const fs = require('fs')
const path = require('path')
const Anvil = require('../src/index')
// const argv = require('yargs')
//   .usage('Usage: $0 pdfTemplateID apiKey jsonPath.json')
//   .option('stream', {
//     alias: 's',
//     type: 'boolean',
//     description: 'Return a stream (default is buffer)',
//   })
//   .option('user-agent', {
//     alias: 'a',
//     type: 'string',
//     description: 'Set the User-Agent on any requests made (default is "Anvil API Client")',
//   })
//   // .demandCommand(3)
//   .argv

// const returnAStream = argv.stream
// const userAgent = argv['user-agent']

// console.log({
//   returnAStream,
//   userAgent,
// })
// process.exit()

const eid = 'Sjl51Zpg1OCKdEtPLC9V'

// Local Dev
const apiKey = 'AXZj09jvHRPNBFRHMnAF2jpwOx9J5Rb6'
// Prod Mango Dev
// const apiKey = 'oBU3hec1pdBRGB5NmSJaj7QQzhiME1u8'

// const jsonPath = ''
const payload = {
  title: 'My PDF Title',
  fontSize: 10,
  textColor: '#CC0000',
  data: {
    someFieldId: 'Hello World!',
  },
}

// const [eid, apiKey, jsonPath] = argv._
const baseURL = 'http://localhost:3000'
const exampleData = payload
// const exampleData = JSON.parse(fs.readFileSync(jsonPath, { encoding: 'utf8' }))

// console.log({
//   exampleData,
// })

// process.exit()

const constructorOptions = {
  apiKey,
  // cookie: 'koa:sess=c2a23c802c7c9e09016378f74ef1ee1d; koa:sess.sig=PO0AfdOUgUcsLFhFLbaz7QgGncU',
  baseURL,
  // userAgent,
  debug: true,
}

// REST API
async function rest () {
  const client = new Anvil(constructorOptions)

  const dataType = returnAStream ? 'stream' : 'buffer'
  // const dataType = 'foo'

  const response = await client.fillPDF(eid, exampleData, { dataType })
  // console.log(response)
  // process.exit()

  const { statusCode, data, errors } = response

  if (statusCode === 200) {
    const scriptDir = __dirname
    const outputFilePath = path.join(scriptDir, 'fill.output.pdf')
    if (dataType === 'stream') {
      console.log('streaming....')
      const writeStream = fs.createWriteStream(outputFilePath, { encoding: null })
      await new Promise((resolve, reject) => {
        data.pipe(writeStream)
        data.on('error', reject)
        writeStream.on('finish', resolve)
      })
    } else {
      console.log('buffering...')
      fs.writeFileSync(outputFilePath, data, { encoding: null })
    }

    console.log('...done')
  } else {
    console.log(statusCode, JSON.stringify(errors || data, null, 2))
  }
}

// GRAPHQL API

// https://github.com/jaydenseric/graphql-upload/issues/125#issuecomment-440853538
// https://zach.codes/building-a-file-upload-hook/
// https://github.com/jaydenseric/graphql-react/blob/1b1234de5de46b7a0029903a1446dcc061f37d09/src/universal/graphqlFetchOptions.mjs
// https://www.npmjs.com/package/extract-files

const filePath = '/Users/newhouse/projects/anvil/node-anvil/scratch/dummy.pdf'
// const filePath = '/Users/newhouse/projects/anvil/node-anvil/scratch/anvil-finovate-non-qualified.pdf'
const userUploadPath = '/Users/newhouse/projects/anvil/node-anvil/scratch/excellent.png'

async function gql () {
  const client = new Anvil(constructorOptions)
  // const fileOneStream = fs.createReadStream('/Users/newhouse/projects/anvil/node-anvil/dummy.pdf')
  // const fileOne = fs.createReadStream('/Users/newhouse/projects/anvil/node-anvil/dummy.pdf')
  // const fileOne = await Anvil.prepareGraphQLFile(fileOneStream)
  const fileOne = Anvil.prepareGraphQLFile(filePath)
  const userUploadOne = Anvil.prepareGraphQLFile(userUploadPath)
  // const fileOne = await Anvil.prepareGraphQLFile('/Users/newhouse/projects/anvil/node-anvil/dummyy.pdf')
  // const fileOne = await Anvil._prepareGraphQLBuffer('/Users/newhouse/projects/anvil/node-anvil/dummy.pdf',
  //   { filename: 'dummypee.pdf', mimetype: 'application/pdf' },
  // )

  console.log({ fileOne })
  // const file = fileOne.file
  // console.log('fillll', file)
  // const outputFilePath = path.join(__dirname, 'wtf.output.pdf')
  // console.log('streaming....')
  // const writeStream = fs.createWriteStream(outputFilePath, { encoding: null })
  // await new Promise((resolve, reject) => {
  //   file.pipe(writeStream)
  //   file.on('error', reject)
  //   writeStream.on('finish', resolve)
  // })

  const base64Data = fs.readFileSync(filePath, { encoding: 'base64' })
  const base64File = Anvil._prepareGraphQLBase64(
    base64Data,
    {
      filename: 'base64.pdf',
      mimetype: 'application/pdf',
      // bufferize: true,
    },
  )
  // console.log(base64File)

  // process.exit()

  const variables = {
    // organizationEid: 'ymMtHQiaewx3Wn2IZGAW',
    // isDraft: true,
    isDraft: false,
    // isTest: true,
    signers: [
      {
        id: 'chissyOneOne',
        name: 'Chissy PooBlouse',
        email: 'newhouse@useanvil.com',
        signerType: 'embedded',
        redirectURL: 'https://yahoo.com',
        fields: [
          {
            fileId: 'fileOne',
            fieldId: 'aDateField',
          },
          {
            fileId: 'fileOne',
            fieldId: 'aSignatureField',
          },
        ],
      },
    ],
    data: {
      payloads: {},
      signers: {
        chissyOneOne: {
          // name: 'Chissy Chissy Woo Woo',
          email: 'foohouse@useanvil.com',
        },
      },
    },
    files: [
      {
        id: 'fileOne',
        file: fileOne,
        fontSize: 18,
        textColor: '#abc123',
        // pageSizes: [
        //   {
        //     width: 612,
        //     height: 792,
        //   },
        //   {
        //     width: 612,
        //     height: 792,
        //   },
        // ],
        fields: [
          {
            id: 'aDateField',
            type: 'signatureDate',
            pageNum: 1,
            rect: {
              x: 203.88,
              y: 171.66,
              width: 33.94,
              height: 27.60,
            },
          },
          {
            id: 'aSignatureField',
            type: 'signature',
            pageNum: 1,
            rect: {
              x: 203.88,
              y: 171.66,
              width: 33.94,
              height: 27.60,
            },
          },
        ],
      },
      {
        id: 'base64upload',
        title: 'Important PDF',
        file: base64File,
        fields: [
          {
            id: 'anotherSignatureFields',
            type: 'signature',
            pageNum: 1,
            rect: {
              x: 203.88,
              y: 171.66,
              width: 33.94,
              height: 27.60,
            },
          },
        ],
      },
      // {
      //   id: 'castReference',
      //   castEid: 'BOWn9mfTZb6rphFcqq8H',
      // },
      {
        id: 'excellentPng',
        file: userUploadOne,
      },
    ],
  }

  // console.log({ variables })

  // console.log("file0")
  // console.log(variables.files[0].file)

  let responseQuery
  responseQuery = undefined

  responseQuery = `{
    id
    eid
    payload
    documentGroup {
      signers {
        id
        eid
        aliasId
        routingOrder
        etchSignURL
        providerConfig
      }
    }
    etchTemplate {
      id
      eid
      config
      casts {
        id
        eid
        config
      }
      userUploads {
        id
        eid
        location
        metadata
      }
    }
  }
  `

  // responseQuery = undefined

  const response = await client.createEtchPacket({ variables, responseQuery })
  const {
    statusCode,
    data,
    errors,
  } = response

  console.log(response)
  console.log({ statusCode, errors })
  console.log(JSON.stringify(data))

  // const dataType = returnAStream ? 'stream' : 'buffer'
  // const dataType = 'foo'
  // const response = await client.getCurrentUser()
  // console.log(response.data.data.currentUser)
}

// rest()
gql()
  .then(() => {
    process.exit(0)
  })
  .catch((err) => {
    console.log(err.stack || err.message)
    process.exit(1)
  })
