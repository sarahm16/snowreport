// https://www.npmjs.com/package/node-fetch#fetch-options
// https://github.com/form-data/form-data#void-append-string-field-mixed-value--mixed-options-
// https://www.npmjs.com/package/extract-files/v/6.0.0#type-extractablefilematcher
// https://github.com/jaydenseric/graphql-upload/issues/125
// https://zach.codes/building-a-file-upload-hook/
// https://github.com/jaydenseric/graphql-react/blob/1b1234de5de46b7a0029903a1446dcc061f37d09/src/universal/graphqlFetchOptions.mjs

// https://www.npmjs.com/package/file-type
// https://www.npmjs.com/package/buffer-peek-stream

const fs = require('fs')
const path = require('path')
const Anvil = require('../src/index')

const eid = 'eLeamc015ZTouxSaA6fy'

// Local Dev
// Dev Key
// const apiKey = '7R3ElJ1sGusHS3eQAiRUKG6QjhSQ1IHE'
// Prod Key
const apiKey = 'AXZj09jvHRPNBFRHMnAF2jpwOx9J5Rb6'
// Prod Mango Dev
// const apiKey = 'oBU3hec1pdBRGB5NmSJaj7QQzhiME1u8'

// const [eid, apiKey, jsonPath] = argv._
const baseURL = 'http://localhost:3000'

const constructorOptions = {
  apiKey,
  // cookie: 'koa:sess=c2a23c802c7c9e09016378f74ef1ee1d; koa:sess.sig=PO0AfdOUgUcsLFhFLbaz7QgGncU',
  baseURL,
  // userAgent,
  debug: true,
}

// GRAPHQL API

// https://github.com/jaydenseric/graphql-upload/issues/125#issuecomment-440853538
// https://zach.codes/building-a-file-upload-hook/
// https://github.com/jaydenseric/graphql-react/blob/1b1234de5de46b7a0029903a1446dcc061f37d09/src/universal/graphqlFetchOptions.mjs
// https://www.npmjs.com/package/extract-files

// const filePath = '/Users/newhouse/projects/anvil/node-anvil/scratch/dummy.pdf'
const filePath = '/Users/newhouse/projects/anvil/node-anvil/scratch/anvil-finovate-non-qualified.pdf'

const client = new Anvil(constructorOptions)
// const fileOneStream = fs.createReadStream('/Users/newhouse/projects/anvil/node-anvil/dummy.pdf')
// const fileOne = fs.createReadStream('/Users/newhouse/projects/anvil/node-anvil/dummy.pdf')
// const fileOne = await Anvil.prepareGraphQLFile(fileOneStream)
const fileOne = Anvil.prepareGraphQLFile(filePath)
// const fileOne = await Anvil.prepareGraphQLFile('/Users/newhouse/projects/anvil/node-anvil/dummyy.pdf')
// const fileOne = await Anvil._prepareGraphQLBuffer('/Users/newhouse/projects/anvil/node-anvil/dummy.pdf',
//   { filename: 'dummypee.pdf', mimetype: 'application/pdf' },
// )

console.log({ fileOne })
// const file = fileOne.file
// console.log('fillll', file)
// const outputFilePath = path.join(__dirname, 'wtf.output.pdf')
// console.log('streaming....')
// const writeStream = fs.createWriteStream(outputFilePath, { encoding: null })
// await new Promise((resolve, reject) => {
//   file.pipe(writeStream)
//   file.on('error', reject)
//   writeStream.on('finish', resolve)
// })

const base64Data = fs.readFileSync(filePath, { encoding: 'base64' })
const base64File = Anvil._prepareGraphQLBase64(
  base64Data,
  {
    filename: 'base64.pdf',
    mimetype: 'application/pdf',
    // bufferize: true,
  },
)

async function gql () {

  // console.log(base64File)

  // process.exit()

  const variables = {
    // castEid: eid,
    file: fileOne,
  }

  console.log({ variables })
  // console.log("file0")
  // console.log(variables.files[0].file)

  const response = await client.getPDFInfo({ variables })
  const {
    statusCode,
    data,
    errors,
  } = response

  console.log(response)
  console.log({ statusCode, errors })
  console.log(JSON.stringify(data))

  // const dataType = returnAStream ? 'stream' : 'buffer'
  // const dataType = 'foo'
  // const response = await client.getCurrentUser()
  // console.log(response.data.data.currentUser)
}

// rest()
gql()
  .then(() => {
    process.exit(0)
  })
  .catch((err) => {
    console.log(err.stack || err.message)
    process.exit(1)
  })
